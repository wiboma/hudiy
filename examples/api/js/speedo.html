<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>OBD-II Speedometer</title>
    <style>
        html,
        body {
            margin: 0;
            height: 100%;
            background: transparent;
        }

        #container {
            position: relative;
            width: 100%;
            height: 100%;
        }

        canvas {
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            display: block;
        }

        @font-face {
            font-family: 'Roboto';
            src: url('Roboto-Regular.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
            font-display: swap;
        }
    </style>
</head>

<body>
    <div id="container">
        <canvas id="backgroundCanvas"></canvas>
        <canvas id="needleCanvas"></canvas>
    </div>

    <script src="common/protobuf.min.js"></script>
    <script type="module">
        import { HudiyClient } from './common/hudiy_client.js';

        const bgCanvas = document.getElementById("backgroundCanvas");
        const needleCanvas = document.getElementById("needleCanvas");
        const bgCtx = bgCanvas.getContext("2d");
        const needleCtx = needleCanvas.getContext("2d");

        const minSpeed = 0;
        const maxSpeed = 280;
        let speed = 0;
        let targetSpeed = 0;
        let animating = false;
        let cx = 0, cy = 0, radius = 0;

        function drawArc(cx, cy, r, start, end, color, width, ctx) {
            ctx.beginPath();
            ctx.arc(cx, cy, r, start, end);
            ctx.strokeStyle = color;
            ctx.lineWidth = width;
            ctx.stroke();
        }

        function drawOuterGlassRing(ctx) {
            const outer = radius * 1.1, inner = radius * 1.02;
            const grad = ctx.createLinearGradient(cx, cy - outer, cx, cy + outer);
            grad.addColorStop(0.0, "rgba(255,255,255,0.2)");
            grad.addColorStop(0.4, "rgba(180,220,255,0.08)");
            grad.addColorStop(0.7, "rgba(0,0,0,0.08)");
            grad.addColorStop(1.0, "rgba(0,0,0,0.2)");

            ctx.save();
            ctx.beginPath();
            ctx.arc(cx, cy, outer, 0, 2 * Math.PI);
            ctx.arc(cx, cy, inner, 0, 2 * Math.PI, true);
            ctx.closePath();
            ctx.fillStyle = grad;
            ctx.fill("evenodd");

            drawArc(cx, cy, outer - 1, 0, Math.PI * 2, "rgba(255,255,255,0.25)", 1, ctx);
            drawArc(cx, cy, inner + 0.5, 0, Math.PI * 2, "rgba(255,255,255,0.08)", 1, ctx);
            ctx.restore();
        }

        function drawGlassReflection(ctx) {
            const r = radius * 1.07;
            const grad = ctx.createLinearGradient(cx, cy - r, cx, cy);
            grad.addColorStop(0.0, "rgba(255,255,255,0.08)");
            grad.addColorStop(0.5, "rgba(255,255,255,0.03)");
            grad.addColorStop(1.0, "rgba(255,255,255,0)");

            ctx.save();
            ctx.beginPath();
            ctx.arc(cx, cy, r, 0, 2 * Math.PI);
            ctx.clip();
            ctx.beginPath();
            ctx.arc(cx, cy, r, Math.PI, 2 * Math.PI);
            ctx.fillStyle = grad;
            ctx.fill();
            ctx.restore();
        }

        function drawDial(ctx) {
            const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, radius + 10);
            grad.addColorStop(0.6, "#001020");
            grad.addColorStop(1.0, "#000000");
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.arc(cx, cy, radius + 10, 0, 2 * Math.PI);
            ctx.fill();

            for (let s = minSpeed; s <= maxSpeed; s += 5) {
                const angle = Math.PI * (0.75 + 1.5 * (s - minSpeed) / (maxSpeed - minSpeed));
                const isMajor = s % 20 === 0;
                const isMedium = s % 10 === 0;
                const len = isMajor ? radius * 0.1 : (isMedium ? radius * 0.06 : radius * 0.03);
                const inner = radius - len;
                const outer = radius - 2;
                const x1 = cx + Math.cos(angle) * inner;
                const y1 = cy + Math.sin(angle) * inner;
                const x2 = cx + Math.cos(angle) * outer;
                const y2 = cy + Math.sin(angle) * outer;

                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.strokeStyle = "#ccc";
                ctx.lineWidth = isMajor ? 2 : 1;
                ctx.stroke();

                if (isMajor) {
                    const adjust = s >= 100 ? radius * 0.01 : 0;
                    const tx = cx + Math.cos(angle) * (radius - radius * 0.24 - adjust);
                    const ty = cy + Math.sin(angle) * (radius - radius * 0.24 - adjust);
                    ctx.fillStyle = "white";
                    ctx.font = `${radius * 0.12}px Roboto`;
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    ctx.fillText(s.toString(), tx, ty);
                }
            }

            ctx.fillStyle = "#aaa";
            ctx.font = `${radius * 0.10}px Roboto`;
            ctx.fillText("km/h", cx, cy + radius * 0.3);
        }

        function drawNeedle(value, ctx) {
            const clamped = Math.min(Math.max(value, minSpeed), maxSpeed);
            const angle = Math.PI * (0.75 + 1.5 * (clamped - minSpeed) / (maxSpeed - minSpeed));
            const x = cx + Math.cos(angle) * (radius - 10);
            const y = cy + Math.sin(angle) * (radius - 10);

            ctx.clearRect(0, 0, needleCanvas.width, needleCanvas.height);

            ctx.save();
            ctx.beginPath();
            ctx.moveTo(cx, cy);
            ctx.lineTo(x, y);
            ctx.strokeStyle = "rgba(0, 0, 0, 0.4)";
            ctx.lineWidth = 4;
            ctx.shadowColor = "rgba(0, 0, 0, 0.8)";
            ctx.shadowBlur = 6;
            ctx.stroke();
            ctx.restore();

            const grad = ctx.createLinearGradient(cx, cy, x, y);
            grad.addColorStop(0, "rgba(255, 0, 0, 1)");
            grad.addColorStop(1, "rgba(255, 0, 0, 0.3)");

            ctx.save();
            ctx.shadowColor = "rgba(255, 0, 0, 0.6)";
            ctx.shadowBlur = 12;
            ctx.beginPath();
            ctx.moveTo(cx, cy);
            ctx.lineTo(x, y);
            ctx.strokeStyle = grad;
            ctx.lineWidth = 3;
            ctx.stroke();
            ctx.restore();

            ctx.beginPath();
            ctx.arc(cx, cy, radius * 0.04, 0, 2 * Math.PI);
            ctx.fillStyle = "black";
            ctx.fill();
            ctx.strokeStyle = "red";
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        function animateNeedle() {
            if (!animating) return;
            speed += (targetSpeed - speed) * 0.3;
            if (Math.abs(targetSpeed - speed) < 0.5) {
                speed = targetSpeed;
                animating = false;
            }
            drawNeedle(speed, needleCtx);
            if (animating) requestAnimationFrame(animateNeedle);
        }

        function startAnimation() {
            if (!animating) {
                animating = true;
                requestAnimationFrame(animateNeedle);
            }
        }

        async function waitForFont(name) {
            if (document.fonts?.load) {
                await document.fonts.load(`12px '${name}'`);
                await document.fonts.ready;
            } else {
                await new Promise(resolve => setTimeout(resolve, 100));
            }
        }

        function resizeAndRenderStatic() {
            const rect = bgCanvas.getBoundingClientRect();
            bgCanvas.width = rect.width;
            bgCanvas.height = rect.height;
            needleCanvas.width = rect.width;
            needleCanvas.height = rect.height;

            cx = rect.width / 2;
            cy = rect.height / 2;
            radius = Math.min(rect.width, rect.height) * 0.45;

            drawDial(bgCtx);
            drawOuterGlassRing(bgCtx);
            drawGlassReflection(bgCtx);
            drawNeedle(speed, needleCtx);
        }

        const hudiy = { api: {} };
        const root = await protobuf.load("common/Api.proto");

        hudiy.api.protoRoot = root;
        hudiy.api.HelloRequest = root.lookupType("hudiy.app.api.HelloRequest");
        hudiy.api.HelloResponse = root.lookupType("hudiy.app.api.HelloResponse");
        hudiy.api.HelloResponseResult = root.lookup("hudiy.app.api.HelloResponse.HelloResponseResult").values;
        hudiy.api.QueryObdDeviceRequest = root.lookupType("hudiy.app.api.QueryObdDeviceRequest");
        hudiy.api.QueryObdDeviceResponse = root.lookupType("hudiy.app.api.QueryObdDeviceResponse");
        hudiy.api.MessageType = root.lookup("hudiy.app.api.MessageType").values;
        hudiy.api.client = new HudiyClient("ws://localhost:44406");

        function sendQueryObdSpeedRequest() {
            const msg = hudiy.api.QueryObdDeviceRequest.create({ commands: ["010D"], requestCode: 0 });
            const payload = hudiy.api.QueryObdDeviceRequest.encode(msg).finish();
            hudiy.api.client.sendMessage(hudiy.api.MessageType.MESSAGE_QUERY_OBD_DEVICE_REQUEST, 0, payload);
        }

        hudiy.api.client.onOpen = () => {
            const hello = hudiy.api.HelloRequest.create({ name: "Speedometer", apiVersion: { major: 1, minor: 0 } });
            const payload = hudiy.api.HelloRequest.encode(hello).finish();
            hudiy.api.client.sendMessage(hudiy.api.MessageType.MESSAGE_HELLO_REQUEST, 0, payload);
        };

        hudiy.api.client.onMessage = ({ id, payload }) => {
            if (id === hudiy.api.MessageType.MESSAGE_HELLO_RESPONSE) {
                const msg = hudiy.api.HelloResponse.decode(payload);
                if (msg.result === hudiy.api.HelloResponseResult.HELLO_RESPONSE_RESULT_OK) {
                    sendQueryObdSpeedRequest();
                }
            } else if (id === hudiy.api.MessageType.MESSAGE_QUERY_OBD_DEVICE_RESPONSE) {
                const msg = hudiy.api.QueryObdDeviceResponse.decode(payload);
                if (msg.requestCode === 0 && msg.result) {
                    const bytes = msg.data[0]?.match(/.{1,2}/g)?.map(h => parseInt(h, 16));
                    targetSpeed = bytes ? bytes[2] : 0;
                    startAnimation();
                    setTimeout(sendQueryObdSpeedRequest, 150);
                }
            } else if (id === hudiy.api.MessageType.MESSAGE_PING) {
                hudiy.api.client.sendMessage(hudiy.api.MessageType.MESSAGE_PONG, 0, new Uint8Array(0));
            }
        };

        hudiy.api.client.connect();

        await waitForFont("Roboto");
        window.addEventListener("resize", resizeAndRenderStatic);
        resizeAndRenderStatic();
    </script>
</body>

</html>