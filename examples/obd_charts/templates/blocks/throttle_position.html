<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OBD Blocks</title>
    <style>
        @font-face {
            font-family: 'Roboto';
            src: url('/static/Roboto-Regular.ttf') format('truetype');
            font-display: swap;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: transparent;
            overflow: hidden;
            font-family: 'Roboto', sans-serif;
            user-select: none;
        }

        .page-top-left {
            position: fixed;
            top: 5vh;
            left: 6vh;
        }

        .page-top-left p {
            margin: 0;
            font-size: 16vmin;
            color: var(--title-color, #efdfd6);
        }

        .center-container {
            position: fixed;
            top: 48%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
        }

        .value-row {
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: center;
        }

        .main-value {
            font-size: 26vmin;
            color: var(--primary-color, #ffb77f);
            margin: 0;
        }

        .value-unit {
            font-size: 16vmin;
            color: var(--primary-color, #ffb77f);
            margin: 0;
            margin-left: 4vmin;
        }

        .chart-wrapper {
            position: fixed;
            bottom: 8vh;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            height: 20vh;
        }

        canvas {
            width: 100%;
            height: 100%;
        }
    </style>
</head>

<body>
    <div class="page-top-left">
        <p>Throttle position</p>
    </div>

    <div class="center-container">
        <div class="value-row">
            <div class="main-value" id="textValue">--</div>
            <div class="value-unit">%</div>
        </div>
    </div>

    <div class="chart-wrapper">
        <canvas id="canvasChart"></canvas>
    </div>

    <script>
        const CONFIG = {
            apiUrl: "http://127.0.0.1:44411",
            pid: "0111",
            minVal: 0,
            maxVal: 100,
            interval: 5000,
            segments: 24
        };

        const state = {
            currentValue: CONFIG.minVal,
            primaryColor: "#ffb77e",
            primaryContainerColor: "#6c3a07",
            onSurfaceColor: "#efdfd6"
        };

        const els = {
            value: document.getElementById('textValue'),
            canvas: document.getElementById('canvasChart'),
            ctx: document.getElementById('canvasChart').getContext('2d')
        };

        const hudiy = {
            colorScheme: { primary: state.primaryColor, onSurface: state.onSurfaceColor, primaryContainer: state.primaryContainerColor },
            onColorSchemeChanged: updateColors,
            onAttached: updateColors
        };

        function parsePidValue(data) {
            const bytes = data.match(/.{1,2}/g)?.map(h => parseInt(h, 16));
            if (!bytes || bytes.length < 3) return CONFIG.minVal;
            return (bytes[2] * 100) / 255;
        }

        function hexToRgba(hex, alpha) {
            if (!/^#([A-Fa-f0-9]{3}){1,2}$/.test(hex)) return hex;
            let c = hex.substring(1).split('');
            if (c.length === 3) c = [c[0], c[0], c[1], c[1], c[2], c[2]];
            c = parseInt(c.join(''), 16);
            return `rgba(${(c >> 16) & 255}, ${(c >> 8) & 255}, ${c & 255}, ${alpha})`;
        }

        function updateColors() {
            state.primaryColor = hudiy.colorScheme.primary || state.primaryColor;
            state.onSurfaceColor = hudiy.colorScheme.onSurface || state.onSurfaceColor;
            state.primaryContainerColor = hudiy.colorScheme.onPrimaryContainer || state.primaryContainerColor;

            document.body.style.setProperty('--primary-color', state.primaryColor);
            document.body.style.setProperty('--title-color', state.onSurfaceColor);

            drawChart();
        }

        function drawChart() {
            const { ctx, canvas } = els;
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();

            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);

            const width = rect.width;
            const height = rect.height;

            ctx.clearRect(0, 0, width, height);

            const totalSegments = CONFIG.segments;
            const gap = width * 0.008;
            const segmentWidth = (width - ((totalSegments - 1) * gap)) / totalSegments;

            let percent = (state.currentValue - CONFIG.minVal) / (CONFIG.maxVal - CONFIG.minVal);
            percent = Math.max(0, Math.min(1, percent));

            const activeIndex = Math.floor(percent * totalSegments);

            for (let i = 0; i < totalSegments; i++) {
                const x = i * (segmentWidth + gap);

                if (i < activeIndex) {
                    ctx.fillStyle = state.primaryColor;
                } else {
                    ctx.fillStyle = hexToRgba(state.primaryContainerColor, 0.15);
                }

                roundRect(ctx, x, 0, segmentWidth, height, 2);
                ctx.fill();
            }
        }

        function roundRect(ctx, x, y, w, h, r) {
            if (w < 2 * r) r = w / 2;
            if (h < 2 * r) r = h / 2;
            ctx.beginPath();
            ctx.moveTo(x + r, y);
            ctx.arcTo(x + w, y, x + w, y + h, r);
            ctx.arcTo(x + w, y + h, x, y + h, r);
            ctx.arcTo(x, y + h, x, y, r);
            ctx.arcTo(x, y, x + w, y, r);
            ctx.closePath();
        }

        async function fetchData(endpoint) {
            try {
                const res = await fetch(`${CONFIG.apiUrl}/${endpoint}?pid=${CONFIG.pid}`);
                if (!res.ok) throw new Error(endpoint);
                return await res.json();
            } catch (e) {
                return null;
            }
        }

        async function init() {
            updateLoop();
            setInterval(updateLoop, CONFIG.interval);
        }

        async function updateLoop() {
            const data = await fetchData('value');
            if (!data || !data.value) return;

            const val = parsePidValue(data.value);
            els.value.innerText = Math.round(val);
            state.currentValue = val;

            drawChart();
        }

        window.addEventListener('resize', () => drawChart());
        init();
    </script>
</body>

</html>